use axelar_wasm_std::counter::Counter;
use axelar_wasm_std::{FnExt, IntoContractError};
use cosmwasm_schema::cw_serde;
use cosmwasm_std::{Addr, StdError, Storage};
use cw_storage_plus::{Item, Map};
use error_stack::report;
use router_api::{ChainName, CrossChainId, Message};

const CONFIG: Item<Config> = Item::new("config");
const ROUTABLE_MESSAGES: Map<&CrossChainId, Message> = Map::new("routable_messages");
pub const ROUTABLE_MESSAGES_INDEX: Counter<u32> = Counter::new("routable_message_index");
const EXECUTABLE_MESSAGES: Map<&CrossChainId, ExecutableMessage> = Map::new("executable_messages");

#[derive(thiserror::Error, Debug, PartialEq, IntoContractError)]
pub enum Error {
    #[error(transparent)]
    Std(#[from] StdError),
    #[error("gateway got into an invalid state, its config is missing")]
    MissingConfig,
    #[error("message with ID {0} mismatches with the stored one")]
    MessageMismatch(CrossChainId),
    #[error("message with ID {0} not found")]
    MessageNotFound(CrossChainId),
    #[error("message with ID {0} not approved")]
    MessageNotApproved(CrossChainId),
    #[error("message with ID {0} already executed")]
    MessageAlreadyExecuted(CrossChainId),
    #[error("sent message with ID {0} already exists")]
    MessageAlreadyExists(CrossChainId),
    #[error("payload hash doesn't match message")]
    PayloadHashMismatch,
}

#[cw_serde]
pub struct Config {
    pub chain_name: ChainName,
    pub router: Addr,
}

#[cw_serde]
pub enum ExecutableMessage {
    /// A message that has been sent by the router, but not executed yet.
    Approved(Message),
    /// An approved message that has been executed.
    Executed(Message),
}

impl ExecutableMessage {
    pub fn msg(&self) -> &Message {
        match self {
            ExecutableMessage::Approved(msg) | ExecutableMessage::Executed(msg) => msg,
        }
    }
}

pub fn save_config(storage: &mut dyn Storage, value: &Config) -> Result<(), Error> {
    Ok(CONFIG.save(storage, value)?)
}

pub fn load_config(storage: &dyn Storage) -> Config {
    CONFIG
        .load(storage)
        .expect("gateway config must be set during instantiation")
}

pub fn save_unique_routable_msg(
    storage: &mut dyn Storage,
    cc_id: &CrossChainId,
    msg: &Message,
) -> Result<(), Error> {
    // these cc IDs are generated by the gateway and should be unique.
    // If there is a collision, there must be a bug in the logic of the caller.
    if ROUTABLE_MESSAGES.has(storage, cc_id) {
        return Err(Error::MessageAlreadyExists(cc_id.clone()));
    }

    Ok(ROUTABLE_MESSAGES.save(storage, cc_id, msg)?)
}

pub fn may_load_routable_msg(
    storage: &dyn Storage,
    id: &CrossChainId,
) -> Result<Option<Message>, Error> {
    Ok(ROUTABLE_MESSAGES.may_load(storage, id)?)
}

pub fn load_routable_msg(storage: &dyn Storage, id: &CrossChainId) -> Result<Message, Error> {
    may_load_routable_msg(storage, id)?.ok_or_else(|| Error::MessageNotFound(id.clone()))
}

pub fn save_executable_msg(
    storage: &mut dyn Storage,
    cc_id: &CrossChainId,
    msg: Message,
) -> Result<(), Error> {
    match may_load_executable_msg(storage, cc_id)? {
        Some(existing) if *existing.msg() != msg => Err(Error::MessageMismatch(msg.cc_id.clone())),
        Some(_) => Ok(()), // new message is identical, no need to store it
        None => Ok(EXECUTABLE_MESSAGES.save(storage, cc_id, &ExecutableMessage::Approved(msg))?),
    }
}

pub fn may_load_executable_msg(
    storage: &dyn Storage,
    cc_id: &CrossChainId,
) -> Result<Option<ExecutableMessage>, Error> {
    Ok(EXECUTABLE_MESSAGES.may_load(storage, cc_id)?)
}

pub fn load_executable_msg(
    storage: &dyn Storage,
    cc_id: &CrossChainId,
) -> Result<ExecutableMessage, Error> {
    may_load_executable_msg(storage, cc_id)?.ok_or_else(|| Error::MessageNotApproved(cc_id.clone()))
}

/// Update the status of a message to executed if it is in approved status, error otherwise.
/// The validation function can define additional checks on the message.
pub fn mark_as_executed(
    storage: &mut dyn Storage,
    cc_id: &CrossChainId,
    // this uses a reference to ensure the caller cannot mutate the message
    validate: impl FnOnce(&Message) -> Result<(), Error>,
) -> Result<Message, Error> {
    let msg = match may_load_executable_msg(storage, cc_id)? {
        None => Err(Error::MessageNotApproved(cc_id.clone())),
        Some(ExecutableMessage::Executed(_)) => Err(Error::MessageAlreadyExecuted(cc_id.clone())),
        Some(ExecutableMessage::Approved(msg)) => validate(&msg)?.then(|_| Ok(msg)),
    }?;

    EXECUTABLE_MESSAGES.save(storage, cc_id, &ExecutableMessage::Executed(msg.clone()))?;

    Ok(msg)
}
