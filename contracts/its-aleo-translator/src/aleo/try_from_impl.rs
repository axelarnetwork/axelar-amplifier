//! Auto-generated TryFrom implementations
//!
//! This file is automatically generated by an internal tool we plan to ship.

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ItsOutgoingInterchainTransfer<N: ::snarkvm_cosmwasm::prelude::Network> {
    pub inner_message: OutgoingInterchainTransfer<N>,
    pub destination_chain: [u128; 2usize],
}
impl<N: ::snarkvm_cosmwasm::prelude::Network> TryFrom<&::snarkvm_cosmwasm::prelude::Plaintext<N>>
    for ItsOutgoingInterchainTransfer<N>
{
    type Error = ::anyhow::Error;
    fn try_from(
        value: &::snarkvm_cosmwasm::prelude::Plaintext<N>,
    ) -> ::anyhow::Result<Self, Self::Error> {
        let ::snarkvm_cosmwasm::prelude::Plaintext::Struct(map, _) = value else {
            ::anyhow::bail!("Expected a Plaintext::Struct. Input value: {:?}", value);
        };
        let inner_message = {
            let key: ::snarkvm_cosmwasm::prelude::Identifier<N> = "inner_message".parse()?;
            let value = map
                .get(&key)
                .ok_or_else(|| ::anyhow::anyhow!("Missing member '{}'", "inner_message"))?;
            let result: ::anyhow::Result<OutgoingInterchainTransfer<N>> = {
                let member_name = "inner_message";
                Ok(OutgoingInterchainTransfer::try_from(value).map_err(|e| {
                    ::anyhow::anyhow!(
                        "Failed to convert Plaintext to {}({}): {}",
                        stringify!(OutgoingInterchainTransfer),
                        member_name,
                        e
                    )
                })?)
            };
            result?
        };
        let destination_chain = {
            let key: ::snarkvm_cosmwasm::prelude::Identifier<N> = "destination_chain".parse()?;
            let value = map
                .get(&key)
                .ok_or_else(|| ::anyhow::anyhow!("Missing member '{}'", "destination_chain"))?;
            let result: ::anyhow::Result<[u128; 2usize]> = {
                let member_name = "destination_chain";
                let ::snarkvm_cosmwasm::prelude::Plaintext::Array(elements, _) = value else {
                    ::anyhow::bail!("Expected a Plaintext::Array for member '{member_name}'");
                };
                if elements.len() != 2usize {
                    ::anyhow::bail!(
                        "Array length mismatch for member '{member_name}': expected {}, got {}",
                        2usize,
                        elements.len()
                    );
                }
                let converted_elements = elements
                    .iter()
                    .map(|element| {
                        let value = element;
                        let result: ::anyhow::Result<u128> = {
                            let ::snarkvm_cosmwasm::prelude::Plaintext::Literal(
                                ::snarkvm_cosmwasm::prelude::Literal::U128(val),
                                _,
                            ) = value
                            else {
                                ::anyhow::bail!(
                                    "Expected a Plaintext::Literal({}) for member '{member_name}'",
                                    "U128"
                                );
                            };
                            Ok(**val)
                        };
                        result
                    })
                    .collect::<::anyhow::Result<Vec<_>>>()?;
                let arr: [u128; 2usize] = converted_elements
                    .try_into()
                    .map_err(|_| ::anyhow::anyhow!("Failed to convert Vec to array"))?;
                Ok(arr)
            };
            result?
        };
        Ok(Self {
            inner_message,
            destination_chain,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FromRemoteDeployInterchainToken<N: ::snarkvm_cosmwasm::prelude::Network> {
    pub its_token_id: [u128; 2usize],
    pub name: u128,
    pub symbol: u128,
    pub decimals: u8,
    pub minter: ::snarkvm_cosmwasm::prelude::Address<N>,
}
impl<N: ::snarkvm_cosmwasm::prelude::Network> TryFrom<&FromRemoteDeployInterchainToken<N>>
    for ::snarkvm_cosmwasm::prelude::Plaintext<N>
{
    type Error = ::anyhow::Error;
    fn try_from(value: &FromRemoteDeployInterchainToken<N>) -> ::anyhow::Result<Self, Self::Error> {
        let mut map = ::indexmap::IndexMap::new();
        {
            map.insert("its_token_id".parse()?, {
                let elements = value
                    .its_token_id
                    .iter()
                    .map(
                        |element| -> ::anyhow::Result<::snarkvm_cosmwasm::prelude::Plaintext<N>> {
                            Ok(::snarkvm_cosmwasm::prelude::Plaintext::from(
                                ::snarkvm_cosmwasm::prelude::Literal::U128(
                                    ::snarkvm_cosmwasm::prelude::U128::new(*element),
                                ),
                            ))
                        },
                    )
                    .collect::<::anyhow::Result<Vec<_>>>()?;
                ::snarkvm_cosmwasm::prelude::Plaintext::Array(
                    elements,
                    ::std::default::Default::default(),
                )
            });
        }
        {
            map.insert(
                "name".parse()?,
                ::snarkvm_cosmwasm::prelude::Plaintext::from(
                    ::snarkvm_cosmwasm::prelude::Literal::U128(
                        ::snarkvm_cosmwasm::prelude::U128::new(value.name),
                    ),
                ),
            );
        }
        {
            map.insert(
                "symbol".parse()?,
                ::snarkvm_cosmwasm::prelude::Plaintext::from(
                    ::snarkvm_cosmwasm::prelude::Literal::U128(
                        ::snarkvm_cosmwasm::prelude::U128::new(value.symbol),
                    ),
                ),
            );
        }
        {
            map.insert(
                "decimals".parse()?,
                ::snarkvm_cosmwasm::prelude::Plaintext::from(
                    ::snarkvm_cosmwasm::prelude::Literal::U8(::snarkvm_cosmwasm::prelude::U8::new(
                        value.decimals,
                    )),
                ),
            );
        }
        {
            map.insert(
                "minter".parse()?,
                ::snarkvm_cosmwasm::prelude::Plaintext::from(
                    ::snarkvm_cosmwasm::prelude::Literal::Address(value.minter),
                ),
            );
        }
        let plaintext =
            ::snarkvm_cosmwasm::prelude::Plaintext::Struct(map, ::std::sync::OnceLock::new());
        Ok(plaintext)
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct RemoteDeployInterchainToken {
    pub payload: DeployInterchainToken,
    pub destination_chain: [u128; 2usize],
}
impl<N: ::snarkvm_cosmwasm::prelude::Network> TryFrom<&::snarkvm_cosmwasm::prelude::Plaintext<N>>
    for RemoteDeployInterchainToken
{
    type Error = ::anyhow::Error;
    fn try_from(
        value: &::snarkvm_cosmwasm::prelude::Plaintext<N>,
    ) -> ::anyhow::Result<Self, Self::Error> {
        let ::snarkvm_cosmwasm::prelude::Plaintext::Struct(map, _) = value else {
            ::anyhow::bail!("Expected a Plaintext::Struct. Input value: {:?}", value);
        };
        let payload = {
            let key: ::snarkvm_cosmwasm::prelude::Identifier<N> = "payload".parse()?;
            let value = map
                .get(&key)
                .ok_or_else(|| ::anyhow::anyhow!("Missing member '{}'", "payload"))?;
            let result: ::anyhow::Result<DeployInterchainToken> = {
                let member_name = "payload";
                Ok(DeployInterchainToken::try_from(value).map_err(|e| {
                    ::anyhow::anyhow!(
                        "Failed to convert Plaintext to {}({}): {}",
                        stringify!(DeployInterchainToken),
                        member_name,
                        e
                    )
                })?)
            };
            result?
        };
        let destination_chain = {
            let key: ::snarkvm_cosmwasm::prelude::Identifier<N> = "destination_chain".parse()?;
            let value = map
                .get(&key)
                .ok_or_else(|| ::anyhow::anyhow!("Missing member '{}'", "destination_chain"))?;
            let result: ::anyhow::Result<[u128; 2usize]> = {
                let member_name = "destination_chain";
                let ::snarkvm_cosmwasm::prelude::Plaintext::Array(elements, _) = value else {
                    ::anyhow::bail!("Expected a Plaintext::Array for member '{member_name}'");
                };
                if elements.len() != 2usize {
                    ::anyhow::bail!(
                        "Array length mismatch for member '{member_name}': expected {}, got {}",
                        2usize,
                        elements.len()
                    );
                }
                let converted_elements = elements
                    .iter()
                    .map(|element| {
                        let value = element;
                        let result: ::anyhow::Result<u128> = {
                            let ::snarkvm_cosmwasm::prelude::Plaintext::Literal(
                                ::snarkvm_cosmwasm::prelude::Literal::U128(val),
                                _,
                            ) = value
                            else {
                                ::anyhow::bail!(
                                    "Expected a Plaintext::Literal({}) for member '{member_name}'",
                                    "U128"
                                );
                            };
                            Ok(**val)
                        };
                        result
                    })
                    .collect::<::anyhow::Result<Vec<_>>>()?;
                let arr: [u128; 2usize] = converted_elements
                    .try_into()
                    .map_err(|_| ::anyhow::anyhow!("Failed to convert Vec to array"))?;
                Ok(arr)
            };
            result?
        };
        Ok(Self {
            payload,
            destination_chain,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ItsIncomingInterchainTransfer<N: ::snarkvm_cosmwasm::prelude::Network> {
    pub inner_message: IncomingInterchainTransfer<N>,
    pub source_chain: [u128; 2usize],
}
impl<N: ::snarkvm_cosmwasm::prelude::Network> TryFrom<&ItsIncomingInterchainTransfer<N>>
    for ::snarkvm_cosmwasm::prelude::Plaintext<N>
{
    type Error = ::anyhow::Error;
    fn try_from(value: &ItsIncomingInterchainTransfer<N>) -> ::anyhow::Result<Self, Self::Error> {
        let mut map = ::indexmap::IndexMap::new();
        {
            map.insert(
                "inner_message".parse()?,
                ::snarkvm_cosmwasm::prelude::Plaintext::try_from(&value.inner_message)?,
            );
        }
        {
            map.insert("source_chain".parse()?, {
                let elements = value
                    .source_chain
                    .iter()
                    .map(
                        |element| -> ::anyhow::Result<::snarkvm_cosmwasm::prelude::Plaintext<N>> {
                            Ok(::snarkvm_cosmwasm::prelude::Plaintext::from(
                                ::snarkvm_cosmwasm::prelude::Literal::U128(
                                    ::snarkvm_cosmwasm::prelude::U128::new(*element),
                                ),
                            ))
                        },
                    )
                    .collect::<::anyhow::Result<Vec<_>>>()?;
                ::snarkvm_cosmwasm::prelude::Plaintext::Array(
                    elements,
                    ::std::default::Default::default(),
                )
            });
        }
        let plaintext =
            ::snarkvm_cosmwasm::prelude::Plaintext::Struct(map, ::std::sync::OnceLock::new());
        Ok(plaintext)
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct IncomingInterchainTransfer<N: ::snarkvm_cosmwasm::prelude::Network> {
    pub its_token_id: [u128; 2usize],
    pub source_address: [u128; 6usize],
    pub destination_address: ::snarkvm_cosmwasm::prelude::Address<N>,
    pub amount: u128,
}
impl<N: ::snarkvm_cosmwasm::prelude::Network> TryFrom<&IncomingInterchainTransfer<N>>
    for ::snarkvm_cosmwasm::prelude::Plaintext<N>
{
    type Error = ::anyhow::Error;
    fn try_from(value: &IncomingInterchainTransfer<N>) -> ::anyhow::Result<Self, Self::Error> {
        let mut map = ::indexmap::IndexMap::new();
        {
            map.insert("its_token_id".parse()?, {
                let elements = value
                    .its_token_id
                    .iter()
                    .map(
                        |element| -> ::anyhow::Result<::snarkvm_cosmwasm::prelude::Plaintext<N>> {
                            Ok(::snarkvm_cosmwasm::prelude::Plaintext::from(
                                ::snarkvm_cosmwasm::prelude::Literal::U128(
                                    ::snarkvm_cosmwasm::prelude::U128::new(*element),
                                ),
                            ))
                        },
                    )
                    .collect::<::anyhow::Result<Vec<_>>>()?;
                ::snarkvm_cosmwasm::prelude::Plaintext::Array(
                    elements,
                    ::std::default::Default::default(),
                )
            });
        }
        {
            map.insert("source_address".parse()?, {
                let elements = value
                    .source_address
                    .iter()
                    .map(
                        |element| -> ::anyhow::Result<::snarkvm_cosmwasm::prelude::Plaintext<N>> {
                            Ok(::snarkvm_cosmwasm::prelude::Plaintext::from(
                                ::snarkvm_cosmwasm::prelude::Literal::U128(
                                    ::snarkvm_cosmwasm::prelude::U128::new(*element),
                                ),
                            ))
                        },
                    )
                    .collect::<::anyhow::Result<Vec<_>>>()?;
                ::snarkvm_cosmwasm::prelude::Plaintext::Array(
                    elements,
                    ::std::default::Default::default(),
                )
            });
        }
        {
            map.insert(
                "destination_address".parse()?,
                ::snarkvm_cosmwasm::prelude::Plaintext::from(
                    ::snarkvm_cosmwasm::prelude::Literal::Address(value.destination_address),
                ),
            );
        }
        {
            map.insert(
                "amount".parse()?,
                ::snarkvm_cosmwasm::prelude::Plaintext::from(
                    ::snarkvm_cosmwasm::prelude::Literal::U128(
                        ::snarkvm_cosmwasm::prelude::U128::new(value.amount),
                    ),
                ),
            );
        }
        let plaintext =
            ::snarkvm_cosmwasm::prelude::Plaintext::Struct(map, ::std::sync::OnceLock::new());
        Ok(plaintext)
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct OutgoingInterchainTransfer<N: ::snarkvm_cosmwasm::prelude::Network> {
    pub its_token_id: [u128; 2usize],
    pub source_address: ::snarkvm_cosmwasm::prelude::Address<N>,
    pub destination_address: [u128; 6usize],
    pub amount: u128,
}
impl<N: ::snarkvm_cosmwasm::prelude::Network> TryFrom<&::snarkvm_cosmwasm::prelude::Plaintext<N>>
    for OutgoingInterchainTransfer<N>
{
    type Error = ::anyhow::Error;
    fn try_from(
        value: &::snarkvm_cosmwasm::prelude::Plaintext<N>,
    ) -> ::anyhow::Result<Self, Self::Error> {
        let ::snarkvm_cosmwasm::prelude::Plaintext::Struct(map, _) = value else {
            ::anyhow::bail!("Expected a Plaintext::Struct. Input value: {:?}", value);
        };
        let its_token_id = {
            let key: ::snarkvm_cosmwasm::prelude::Identifier<N> = "its_token_id".parse()?;
            let value = map
                .get(&key)
                .ok_or_else(|| ::anyhow::anyhow!("Missing member '{}'", "its_token_id"))?;
            let result: ::anyhow::Result<[u128; 2usize]> = {
                let member_name = "its_token_id";
                let ::snarkvm_cosmwasm::prelude::Plaintext::Array(elements, _) = value else {
                    ::anyhow::bail!("Expected a Plaintext::Array for member '{member_name}'");
                };
                if elements.len() != 2usize {
                    ::anyhow::bail!(
                        "Array length mismatch for member '{member_name}': expected {}, got {}",
                        2usize,
                        elements.len()
                    );
                }
                let converted_elements = elements
                    .iter()
                    .map(|element| {
                        let value = element;
                        let result: ::anyhow::Result<u128> = {
                            let ::snarkvm_cosmwasm::prelude::Plaintext::Literal(
                                ::snarkvm_cosmwasm::prelude::Literal::U128(val),
                                _,
                            ) = value
                            else {
                                ::anyhow::bail!(
                                    "Expected a Plaintext::Literal({}) for member '{member_name}'",
                                    "U128"
                                );
                            };
                            Ok(**val)
                        };
                        result
                    })
                    .collect::<::anyhow::Result<Vec<_>>>()?;
                let arr: [u128; 2usize] = converted_elements
                    .try_into()
                    .map_err(|_| ::anyhow::anyhow!("Failed to convert Vec to array"))?;
                Ok(arr)
            };
            result?
        };
        let source_address = {
            let key: ::snarkvm_cosmwasm::prelude::Identifier<N> = "source_address".parse()?;
            let value = map
                .get(&key)
                .ok_or_else(|| ::anyhow::anyhow!("Missing member '{}'", "source_address"))?;
            let result: ::anyhow::Result<::snarkvm_cosmwasm::prelude::Address<N>> = {
                let member_name = "source_address";
                let ::snarkvm_cosmwasm::prelude::Plaintext::Literal(
                    ::snarkvm_cosmwasm::prelude::Literal::Address(val),
                    _,
                ) = value
                else {
                    ::anyhow::bail!(
                        "Expected a Plaintext::Literal({}) for member '{member_name}'",
                        "Address"
                    );
                };
                Ok(*val)
            };
            result?
        };
        let destination_address = {
            let key: ::snarkvm_cosmwasm::prelude::Identifier<N> = "destination_address".parse()?;
            let value = map
                .get(&key)
                .ok_or_else(|| ::anyhow::anyhow!("Missing member '{}'", "destination_address"))?;
            let result: ::anyhow::Result<[u128; 6usize]> = {
                let member_name = "destination_address";
                let ::snarkvm_cosmwasm::prelude::Plaintext::Array(elements, _) = value else {
                    ::anyhow::bail!("Expected a Plaintext::Array for member '{member_name}'");
                };
                if elements.len() != 6usize {
                    ::anyhow::bail!(
                        "Array length mismatch for member '{member_name}': expected {}, got {}",
                        6usize,
                        elements.len()
                    );
                }
                let converted_elements = elements
                    .iter()
                    .map(|element| {
                        let value = element;
                        let result: ::anyhow::Result<u128> = {
                            let ::snarkvm_cosmwasm::prelude::Plaintext::Literal(
                                ::snarkvm_cosmwasm::prelude::Literal::U128(val),
                                _,
                            ) = value
                            else {
                                ::anyhow::bail!(
                                    "Expected a Plaintext::Literal({}) for member '{member_name}'",
                                    "U128"
                                );
                            };
                            Ok(**val)
                        };
                        result
                    })
                    .collect::<::anyhow::Result<Vec<_>>>()?;
                let arr: [u128; 6usize] = converted_elements
                    .try_into()
                    .map_err(|_| ::anyhow::anyhow!("Failed to convert Vec to array"))?;
                Ok(arr)
            };
            result?
        };
        let amount = {
            let key: ::snarkvm_cosmwasm::prelude::Identifier<N> = "amount".parse()?;
            let value = map
                .get(&key)
                .ok_or_else(|| ::anyhow::anyhow!("Missing member '{}'", "amount"))?;
            let result: ::anyhow::Result<u128> = {
                let member_name = "amount";
                let ::snarkvm_cosmwasm::prelude::Plaintext::Literal(
                    ::snarkvm_cosmwasm::prelude::Literal::U128(val),
                    _,
                ) = value
                else {
                    ::anyhow::bail!(
                        "Expected a Plaintext::Literal({}) for member '{member_name}'",
                        "U128"
                    );
                };
                Ok(**val)
            };
            result?
        };
        Ok(Self {
            its_token_id,
            source_address,
            destination_address,
            amount,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ItsMessageDeployInterchainToken<N: ::snarkvm_cosmwasm::prelude::Network> {
    pub inner_message: FromRemoteDeployInterchainToken<N>,
    pub source_chain: [u128; 2usize],
}
impl<N: ::snarkvm_cosmwasm::prelude::Network> TryFrom<&ItsMessageDeployInterchainToken<N>>
    for ::snarkvm_cosmwasm::prelude::Plaintext<N>
{
    type Error = ::anyhow::Error;
    fn try_from(value: &ItsMessageDeployInterchainToken<N>) -> ::anyhow::Result<Self, Self::Error> {
        let mut map = ::indexmap::IndexMap::new();
        {
            map.insert(
                "inner_message".parse()?,
                ::snarkvm_cosmwasm::prelude::Plaintext::try_from(&value.inner_message)?,
            );
        }
        {
            map.insert("source_chain".parse()?, {
                let elements = value
                    .source_chain
                    .iter()
                    .map(
                        |element| -> ::anyhow::Result<::snarkvm_cosmwasm::prelude::Plaintext<N>> {
                            Ok(::snarkvm_cosmwasm::prelude::Plaintext::from(
                                ::snarkvm_cosmwasm::prelude::Literal::U128(
                                    ::snarkvm_cosmwasm::prelude::U128::new(*element),
                                ),
                            ))
                        },
                    )
                    .collect::<::anyhow::Result<Vec<_>>>()?;
                ::snarkvm_cosmwasm::prelude::Plaintext::Array(
                    elements,
                    ::std::default::Default::default(),
                )
            });
        }
        let plaintext =
            ::snarkvm_cosmwasm::prelude::Plaintext::Struct(map, ::std::sync::OnceLock::new());
        Ok(plaintext)
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct DeployInterchainToken {
    pub its_token_id: [u128; 2usize],
    pub name: u128,
    pub symbol: u128,
    pub decimals: u8,
    pub minter: [u128; 6usize],
}
impl<N: ::snarkvm_cosmwasm::prelude::Network> TryFrom<&::snarkvm_cosmwasm::prelude::Plaintext<N>>
    for DeployInterchainToken
{
    type Error = ::anyhow::Error;
    fn try_from(
        value: &::snarkvm_cosmwasm::prelude::Plaintext<N>,
    ) -> ::anyhow::Result<Self, Self::Error> {
        let ::snarkvm_cosmwasm::prelude::Plaintext::Struct(map, _) = value else {
            ::anyhow::bail!("Expected a Plaintext::Struct. Input value: {:?}", value);
        };
        let its_token_id = {
            let key: ::snarkvm_cosmwasm::prelude::Identifier<N> = "its_token_id".parse()?;
            let value = map
                .get(&key)
                .ok_or_else(|| ::anyhow::anyhow!("Missing member '{}'", "its_token_id"))?;
            let result: ::anyhow::Result<[u128; 2usize]> = {
                let member_name = "its_token_id";
                let ::snarkvm_cosmwasm::prelude::Plaintext::Array(elements, _) = value else {
                    ::anyhow::bail!("Expected a Plaintext::Array for member '{member_name}'");
                };
                if elements.len() != 2usize {
                    ::anyhow::bail!(
                        "Array length mismatch for member '{member_name}': expected {}, got {}",
                        2usize,
                        elements.len()
                    );
                }
                let converted_elements = elements
                    .iter()
                    .map(|element| {
                        let value = element;
                        let result: ::anyhow::Result<u128> = {
                            let ::snarkvm_cosmwasm::prelude::Plaintext::Literal(
                                ::snarkvm_cosmwasm::prelude::Literal::U128(val),
                                _,
                            ) = value
                            else {
                                ::anyhow::bail!(
                                    "Expected a Plaintext::Literal({}) for member '{member_name}'",
                                    "U128"
                                );
                            };
                            Ok(**val)
                        };
                        result
                    })
                    .collect::<::anyhow::Result<Vec<_>>>()?;
                let arr: [u128; 2usize] = converted_elements
                    .try_into()
                    .map_err(|_| ::anyhow::anyhow!("Failed to convert Vec to array"))?;
                Ok(arr)
            };
            result?
        };
        let name = {
            let key: ::snarkvm_cosmwasm::prelude::Identifier<N> = "name".parse()?;
            let value = map
                .get(&key)
                .ok_or_else(|| ::anyhow::anyhow!("Missing member '{}'", "name"))?;
            let result: ::anyhow::Result<u128> = {
                let member_name = "name";
                let ::snarkvm_cosmwasm::prelude::Plaintext::Literal(
                    ::snarkvm_cosmwasm::prelude::Literal::U128(val),
                    _,
                ) = value
                else {
                    ::anyhow::bail!(
                        "Expected a Plaintext::Literal({}) for member '{member_name}'",
                        "U128"
                    );
                };
                Ok(**val)
            };
            result?
        };
        let symbol = {
            let key: ::snarkvm_cosmwasm::prelude::Identifier<N> = "symbol".parse()?;
            let value = map
                .get(&key)
                .ok_or_else(|| ::anyhow::anyhow!("Missing member '{}'", "symbol"))?;
            let result: ::anyhow::Result<u128> = {
                let member_name = "symbol";
                let ::snarkvm_cosmwasm::prelude::Plaintext::Literal(
                    ::snarkvm_cosmwasm::prelude::Literal::U128(val),
                    _,
                ) = value
                else {
                    ::anyhow::bail!(
                        "Expected a Plaintext::Literal({}) for member '{member_name}'",
                        "U128"
                    );
                };
                Ok(**val)
            };
            result?
        };
        let decimals = {
            let key: ::snarkvm_cosmwasm::prelude::Identifier<N> = "decimals".parse()?;
            let value = map
                .get(&key)
                .ok_or_else(|| ::anyhow::anyhow!("Missing member '{}'", "decimals"))?;
            let result: ::anyhow::Result<u8> = {
                let member_name = "decimals";
                let ::snarkvm_cosmwasm::prelude::Plaintext::Literal(
                    ::snarkvm_cosmwasm::prelude::Literal::U8(val),
                    _,
                ) = value
                else {
                    ::anyhow::bail!(
                        "Expected a Plaintext::Literal({}) for member '{member_name}'",
                        "U8"
                    );
                };
                Ok(**val)
            };
            result?
        };
        let minter = {
            let key: ::snarkvm_cosmwasm::prelude::Identifier<N> = "minter".parse()?;
            let value = map
                .get(&key)
                .ok_or_else(|| ::anyhow::anyhow!("Missing member '{}'", "minter"))?;
            let result: ::anyhow::Result<[u128; 6usize]> = {
                let member_name = "minter";
                let ::snarkvm_cosmwasm::prelude::Plaintext::Array(elements, _) = value else {
                    ::anyhow::bail!("Expected a Plaintext::Array for member '{member_name}'");
                };
                if elements.len() != 6usize {
                    ::anyhow::bail!(
                        "Array length mismatch for member '{member_name}': expected {}, got {}",
                        6usize,
                        elements.len()
                    );
                }
                let converted_elements = elements
                    .iter()
                    .map(|element| {
                        let value = element;
                        let result: ::anyhow::Result<u128> = {
                            let ::snarkvm_cosmwasm::prelude::Plaintext::Literal(
                                ::snarkvm_cosmwasm::prelude::Literal::U128(val),
                                _,
                            ) = value
                            else {
                                ::anyhow::bail!(
                                    "Expected a Plaintext::Literal({}) for member '{member_name}'",
                                    "U128"
                                );
                            };
                            Ok(**val)
                        };
                        result
                    })
                    .collect::<::anyhow::Result<Vec<_>>>()?;
                let arr: [u128; 6usize] = converted_elements
                    .try_into()
                    .map_err(|_| ::anyhow::anyhow!("Failed to convert Vec to array"))?;
                Ok(arr)
            };
            result?
        };
        Ok(Self {
            its_token_id,
            name,
            symbol,
            decimals,
            minter,
        })
    }
}
